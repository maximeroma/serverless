"use strict"

const _ = require("lodash")
const AWS = require("aws-sdk")
const apigateway = new AWS.APIGateway()
const cloudwatch = new AWS.CloudWatch()
const log = require("../lib/log")

const alarmActions = (process.env.alarm_actions || "").split(",")
const okAction = (process.env.ok_actions || "").split(",")

const enableDetailedMetrics = async (restApiId, stageName) => {
  const getResp = await apigateway.getStage({restApiId, stageName}).promise()
  log.debug("get stage settings", getResp.methodSettings)

  const isDetailedMetricsEnabled = _.get(
    getResp,
    "methodSettings.*/*.metricsEnabled",
    false
  )
  if (isDetailedMetricsEnabled) {
    log.debug("detailed metrics already enabled", {restApiId, stageName})
  } else {
    const updateReq = {
      restApiId,
      stageName,
      patchOperations: [
        {
          path: "/*/*/metrics/enabled",
          value: "true",
          op: "replace"
        }
      ]
    }
    await apigateway.updateStage(updateReq).promise()
    log.debug("enabled detailed metrics", {restApiId, stageName})
  }
}

const getRestEndpoints = async restApiId => {
  const resp = await apigateway.getResources({restApiId}).promise()
  log.debug("got REST resources", {restApiId})

  const resourceMethods = resp.items.map(x => {
    const methods = _.keys(x.resourceMethods)
    return methods.map(method => ({resource: x.path, method}))
  })

  return _.flattenDeep(resourceMethods)
}

const getRestApiName = async restApiId => {
  const resp = await apigateway.getRestApi({restApiId}).promise()
  log.debug("got REST api", {restApiId})

  return resp.name
}

const createAlarmsForEndpoints = async (restApiId, stageName) => {
  const apiName = await getRestApiName(restApiId)
  log.debug(`API name is ${apiName}`, {restApiId, stageName})

  const restEndpoints = await getRestEndpoints(restApiId)
  log.debug("got REST endpoints", {restApiId, stageName, restEndpoints})

  for (let endpoint of restEndpoints) {
    const putReq = {
      AlarmName: `API [${apiName}] stage [${stageName}] ${endpoint.method} ${endpoint.resource} : p99 > 1s`,
      MetricName: "Latency",
      Dimensions: [
        {Name: "ApiName", Value: apiName},
        {Name: "Resource", Value: endpoint.resource},
        {Name: "Method", Value: endpoint.method},
        {Name: "Stage", Value: stageName}
      ],
      Namespace: "AWS/ApiGateway",
      Threshold: 1000, // 1s
      ComparisonOperator: "GreaterThanThreshold",
      Period: 60, // per min
      EvaluationPeriods: 5,
      DatapointsToAlarm: 5, // 5 consecutive mins to trigger alarm
      ExtendedStatistic: "p99",
      ActionsEnabled: true,
      AlarmActions: alarmActions,
      AlarmDescription: `auto-generated by Lambda [${process.env.AWS_LAMBDA_FUNCTION_NAME}]`,
      OKActions: okAction,
      Unit: "Milliseconds"
    }
    await cloudwatch.putMetricAlarm(putReq).promise()
  }

  log.debug("auto-created latency ALARMS for REST endpoints", {
    restApiId,
    stageName,
    restEndpoints
  })
}

module.exports.handler = async (event, context, cb) => {
  const restApiId = event.detail.requestParameters.restApiId
  const stageName =
    event.detail.requestParameters.createDeploymentInput.stageName

  await enableDetailedMetrics(restApiId, stageName)

  await createAlarmsForEndpoints(restApiId, stageName)

  cb(null, "ok")
}
